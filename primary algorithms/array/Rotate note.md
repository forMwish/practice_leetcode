# 题目

给定一个数组，长度设为 *n*，大于 1，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。

要求：

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的 **原地** 算法。



# 思路

- 如果不是原地算法，则可以采用计算偏移后位置，然后进行两次 memcpy() 解决。比如数组 ``` a = [1, 2, 3, 4, 5]```，平移 k = 2，则可以通过如下流程完成：

  ```python
b[0:2] = a[3:5]
b[2:5] = a[0:3]
  ```



- 非原地算法实现最简单的就是每次循环右移一次，一共循环 k 次。每次循环使用变量存储第一个值，直到最后的值移动后，再将变量存储的值赋值到最后的位置。实现起来大概如下：

  ```python
  while k:
      temp = a[-1]
    a[1:] = a[0:-1]
      a[0] = temp
      k = k - 1
  ```
  
  该实现需要进行 kn 次平移，时间复杂度为 O(n)。



- 再想想，理论上应该只需要平移 n 次，因为只有 n 个元素，每次将对应元素放到它最终平移的位置即可。综合原地算法的特性，最终实现的步骤应该如下：

  1. 先选择数组中的某个元素，假设该元素在数组中的索引为 $a_0$，将其放到变量存储，则索引 $a_0$ 空出；
  2. 计算应该平移到这里的元素索引 $a_1 = (a_0 - k)$，并将其移动到 $a_0$，则索引 $a_1$ 空出；
  3. 重复步骤1、2，直到应该平移的元素的索引重新变为 $a_0$。此时把变量中存储的数据放到此时空出的索引。

  基本思路是上面这样，但是实现过程中发现不完善的地方。思索后理论上补齐，设 *n* 为数组长度，*k* 为向右平移数，且已经和 *n* 求余，即 $k = k \% n$：

  1. “应该平移的元素的索引重新变为 $a_0$” ，即是 $n$ 和 $k$ 最小公倍数的时候。

  2. 求 $k$ 和 $n$ 的最大公约数，设为 $a$。若 $a$ == 1，则按照前面的 1、2、3 即可完成；若 a != 1 ，则还有未平移的数组元素。因为若最大公约数为1，则到最小公倍数的时候，平移的元素个数已经是数组长度 $n$。若不为 1，则已经平移的元素个数为 $n/a$。需要对其他元素进行平移。



